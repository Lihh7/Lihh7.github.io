<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Lihh7's Blog</title><meta name="author" content="Lihh"><meta name="copyright" content="Lihh"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="专注一点，登峰造极">
<meta property="og:type" content="website">
<meta property="og:title" content="Lihh7&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Lihh7&#39;s Blog">
<meta property="og:description" content="专注一点，登峰造极">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:author" content="Lihh">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Lihh7\'s Blog',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-07-21 17:06:50'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/%E9%9B%AA.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Lihh7's Blog"></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">Lihh7's Blog</h1><div id="site_social_icons"><a class="social-icon" href="https://github.com/Lihh7" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/07/21/Redis/%E5%BA%95%E5%B1%82/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Redis网络模型">Redis网络模型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-07-21T09:01:30.000Z" title="发表于 2024-07-21 17:01:30">2024-07-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/%E5%BA%95%E5%B1%82/">底层</a></span></div><div class="content">Redis 网络模型
内核空间和用户空间
为了避免用户应用导致冲突甚至内核崩溃，把两部分分开
内核空间：可以执行特权命令（R0）
用户空间：只能执行受限的命令（R3）
用户态，内核态相互切换
IO操作速度

来回拷贝
等待



阻塞IO

（阻塞等待）用户等待数据就绪
（阻塞等待）拷贝内核



非阻塞IO

（CPU空转）待数据
（阻塞等待）拷贝


IO多路复用
单线程情况下，依次处理一个
socket，如果前面的未就绪，线程阻塞，所有其他 socket
必须等待，性能很差。
方案：

多线程（上下文切换）
就绪的才来

文件描述符：一个无符号整数，关联一个文件（一切皆文件）
IO多路复用：单线程监听多个
FD，并在某个可读可写得到通知，从而避免无效等待，充分利用 CPU 资源。
一次传了多个 FD，单线程监听。
三种不同形式，差别在于通知方式
只通知有无就绪：

select
poll

通知哪个就绪：

epoll


select
select 函数会传递 fd 上限 和 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/07/21/Redis/%E5%BA%95%E5%B1%82/Redis%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="Redis常用的数据类型">Redis常用的数据类型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-07-21T08:49:42.000Z" title="发表于 2024-07-21 16:49:42">2024-07-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/%E5%BA%95%E5%B1%82/">底层</a></span></div><div class="content">RedisObject
根据类型不同，使用一个头 RedisObject
来记录（这个头占据内存16个字节）

type 数据类型
encoding 底层编码方式
lru 最后一次被访问的时间
refcount 对象引用计数器
ptr 真实数据的指针


底层编码序号
共计11种，然后字符串就有三种
这里的HT就是dict

五种数据类型的编码


String

最常用的编码是
RAW，上限是512MB，基于SDS
如果存储的SDS小于44字节，则采用
EMBSTR编码。这个编码的 RedisObject 和 SDS
是一段连续空间。申请时只需要调用一次内存分配函数。
为什么是44字节？因为SDS中头尾加起来4字节，加上44就是48字节；
同时RedisObject头需要16字节，因此加起来需要64字节；最后 Redis
分配内存刚好是 2^n 分配，不会产生碎片！
如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用INT编码。直接将数据放在
ptr，不需要SDS



List
Redis 的 L ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/07/21/Redis/%E5%BA%95%E5%B1%82/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="Redis底层数据结构">Redis底层数据结构</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-07-21T08:37:24.000Z" title="发表于 2024-07-21 16:37:24">2024-07-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a><i class="fas fa-angle-right article-meta-link"></i><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/%E5%BA%95%E5%B1%82/">底层</a></span></div><div class="content">Redis 底层数据结构
总览

SDS（动态扩容且常量获取长度的字符串）
IntSet（有序整数Set，兼备压缩空间（统一编码）和动态扩容）
Dict （双哈希表组成的字典，动态扩容收缩，渐进式rehash）
ZipList（连续内存的链表，节省了指针压缩内存但是存在连锁更新隐患）
QuickList（以ZipList节点的双端链表）
SkipList（跳表）


SDS（动态扩容且常量获取长度的字符串）
redis中Key是字符串，value往往是字符串或者字符串的集合
但是Redis没有用C语言的字符串，因为它有缺陷

读取长度需要遍历，需要读到
\0
非二进制安全，如果中间有 \0 会被截断
不可修改，保存在常量池

SDS（simple dynamic String） ，简单动态字符串
比如 set name huge
底层会有两个SDS
本质上是一个结构体，里面成员变量
有
sdshdr8，sdshdr16，还有32，64，甚至还有5，已被弃用
1234567//buf已经保存的字符串字节数，不包含结束标识uint8_t  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/07/21/JVM/10-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="10-垃圾回收器">10-垃圾回收器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-07-21T03:35:10.000Z" title="发表于 2024-07-21 11:35:10">2024-07-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span></div><div class="content">垃圾回收器

为什么要分代？

大部分对象都是创建出来然后不再使用，比如订单数据
老年代存放长期存活的对象，比如 Spring 的大部分 Bean
对象，不会回收
默认设置中，新生代远小于老年代
因此：

可以调整年轻代和老年代的比例
采用不同的垃圾回收算法，新生代使用复制算法（清除的对象多，复制少）；老年代可以标记-清除或者标记-整理
分代设计可以只回收新生代（Minor
GC），不需要整个堆进行回收。减少 STW

垃圾回收器分为年轻代和老年代回收器，除了 G1
之外其他都需要组合使用

Serial + Serial Old（串行单线程）
年轻代 复制
老年代标记-整理
ParNew + CMS（关注暂停时间）
年轻代 复制
老年代 标记-清除+整理
老年代CMS回收：初始标记（STW）+并发标记+重新标记（STW）+并发清除
老年代过多，退化 Serial Old
关注点：STW时间，浮动垃圾，碎片问题，退化
Parallel Scavenge + Parallel
Old（关注吞吐量，自动分配堆内存）
年轻代 复制
 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/07/21/JVM/9-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/" title="9-垃圾回收算法">9-垃圾回收算法</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-07-21T03:35:03.000Z" title="发表于 2024-07-21 11:35:03">2024-07-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span></div><div class="content">垃圾回收算法
两件事：

分类
释放内存，再次利用空间

算法：

标记-清除算法
复制算法
标记-整理算法
分代GC

评判标准
都需要单独的GC线程，不管哪个算法都需要一部分停止所有用户线程。Stop
The World（STW），时间不易太长

吞吐量：执行用户代码时间 /
总时间（执行用户代码+GC）
最大暂停时间：STW
堆使用效率

不可兼得

标记清除算法
两个阶段：

标记阶段：所有存活的对象进行标记。
清除阶段：删除没有被标记也就是非存活对象

优点：实现简单，只需要维护标志位
缺点：出现很多内存碎片，同时分配速度慢，需要维护空闲链表，需要遍历链表
复制算法

堆内存分成两块空间，From和To，分配内存只分配在 From 空间
GC阶段开始，把 GC Root 搬运到 To 空间
将 GC Root 关联的的对象，搬运到 To 空间
清理 From 空间，名字互换

优点：

吞吐量高，只需要遍历一次存活对象。但是不如标记清除
无碎片

缺点：

只能使用一半空间

标记 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/07/21/JVM/8-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%9C%80%E8%A6%81%E5%9B%9E%E6%94%B6/" title="8-如何判断需要回收">8-如何判断需要回收</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-07-21T03:34:56.000Z" title="发表于 2024-07-21 11:34:56">2024-07-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span></div><div class="content">如何判断需要回收
自动垃圾回收
C/CPP
没有自动垃圾回收，需要手动释放，否则内存泄漏
Java引入了自动垃圾回收，回收不使用的对象
自动回收
优点：降低难度，降低对象回收BUG的可能
缺点：程序员无法控制及时性
手动回收
优点：回收及时性高
缺点：容易悬空指针，重复释放，内存泄漏
系统僵死：系统忙于垃圾回收

方法区的回收
这里相当于类的生命周期中的卸载
三个条件满足才可以：

这个类的实例对象已经被回收，在堆中不存在任何该类的实例对象以及子类对象
加载这个类的类加载器已经被回收
这个类的 java.lang.Class
对象没有再被引用

System.gc() 手动发送垃圾回收的请求
JSP的热部署：每个Jsp文件对应一个唯一的类加载器，当一个jsp文件被修改了，直接卸载这个
jsp 类加载器，重新创建类加载器，重新加载jsp 文件

堆内存的回收
如何判断堆对象能否被回收？主要看引用
但是需要处理循环引用问题

两种方法： *
引用计数法：每个对象有个计数器维护被引用的次数。但是解决不了循环引用问题，同时计数器需要 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/07/21/JVM/7-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F/" title="7-运行时数据区域">7-运行时数据区域</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-07-21T03:34:42.000Z" title="发表于 2024-07-21 11:34:42">2024-07-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span></div><div class="content">运行时数据区域
线程不共享：

程序计数器
Java虚拟机栈
本地方法栈

线程共享：

方法区
堆



程序计数器
也叫PC寄存器，存放接下来要执行的内存地址。
作用

控制执行，分支，跳转，异常
多线程上下文切换，执行

字节码指令被类加载器拿到内存后，会存在内存。

代码保存到了哪里？


栈
规范规定了两个栈，一个用来保存Java实现的方法，一个用来保存native的cpp方法
但是 hotspot 只用了一个栈
先进后出
栈帧和线程生命周期相同：随着线程创建而创建，同时随着它的销毁后被回收。
栈帧的内容：

局部变量表：局部变量
操作数栈：临时数据
帧数据：动态链接，方法出口，异常表的引用

局部变量表
局部变量表在栈帧中是一个数组，一个位置是 slot ，除了 long 和 double
占用两个槽，其他类型占用一个槽

如果是实例方法：

this引用（内存地址）
方法参数
局部变量

为了节省空间，槽可以复用，某个局部变量不再生效当前槽就可以再次被使用。

操作数栈
栈 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/07/21/JVM/6-JDK9%E4%B9%8B%E5%90%8E%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/" title="6-JDK9之后的类加载器">6-JDK9之后的类加载器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-07-21T03:34:26.000Z" title="发表于 2024-07-21 11:34:26">2024-07-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span></div><div class="content">JDK9之后的类加载器
JDK9之前的版本，extension 和 application 类加载器源码都在
rt.jar 包中的 sun.misc.Launcher.java
JDK9之后引入了 module ，有了 jmod
文件
启动类加载器使用了 Java 编写，位于
jdk.internal.loader.ClassLoader 类中
BootClassLoader 继承自 BuiltinClassLoader
实现从模块中找到字节码资源文件
启动类加载器依然无法通过java代码获取，依然是 null
扩展类加载器被替换成了平台类加载器（Platform Class
Loader），继承从URL变成了 BuiltinClassLoader
，实现从模块加载字节码文件，属于是冗余设计，因为模块化已经具备扩展性。单纯为了兼容，无特殊逻辑
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/07/21/JVM/5-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/" title="5-双亲委派机制">5-双亲委派机制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-07-21T03:34:11.000Z" title="发表于 2024-07-21 11:34:11">2024-07-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span></div><div class="content">多个类加载器，解决一个类到底由谁加载

保证类加载的安全性，保证核心类必须虚拟机自己提供
避免重复加载

每个加载器都有父加载器（不是继承，而是成员变量）

向上委派，如果加载过直接返回，如果没有继续委派
向下尝试加载，如果在自己的路径就加载，如果不在就给下面的加载

因此 String 类不能被覆盖

主动加载一个类

使用 Class.forName
使用当前类的类加载器去加载指定的类
获取类加载器，通过类加载器的 loadClass
指定某个类加载器加载


打破双亲委派机制
三种方式打破

自定义类加载器，重写 loadClass
方法
线程上下文类加载器，利用上下文类加载器加载类，比如
JDBC 和 JNDI
Osgi框架的类加载器，这个允许同级之间委托进行类的加载

为什么要打破
Tomcat 程序可以运行多个Web应用，如果两个应用出现相同限定名的类，比如
Servlet 类，Tomcat
要保证两个类都能被加载并且是不同的类。

自定义类加载器
ClassLoader 包含4个核心方法：

loa ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2024/07/21/JVM/4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB/" title="4-类加载器的分类">4-类加载器的分类</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2024-07-21T03:33:52.000Z" title="发表于 2024-07-21 11:33:52">2024-07-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/JVM/">JVM</a></span></div><div class="content">类加载器的分类
类加载器（ClassLoader）是 JVM
提供给程序去实现类和接口字节码数据的技术

类加载器加载进内存
调用 JNI 本地接口调用（cpp写好的），创建堆和方法区对象


分类

虚拟机底层实现，位于JVM的源码，实现语言和JVM底层一致，一般
cpp。保证加载基础类，比如 java.lang.String
JDK默认提供或者自定义。继承自
ClassLoader

常见的：

虚拟机实现：BootStrap（加载最核心的类）
Java：Extension（扩展通用的），Application（加载自己写的）

启动类加载器（Bootstrap
ClassLoader）
由 Hotspot 虚拟机提供，使用 cpp 编写。默认加载
/jre/lib 的类文件，比如
rt.jar。加载最核心的类。加载后得到基础的环境
123//先获取堆上的对象，然后获取类加载器String.class.getClassLoader();//null//不给获取的，因为是启动加载器（cpp）
如果想加载多一点类：

放入 jre ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><a class="page-number" href="/page/3/#content-inner">3</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lihh</div><div class="author-info__description">专注一点，登峰造极</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Lihh7"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Lihh7" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/21/Redis/%E5%BA%95%E5%B1%82/Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/" title="Redis网络模型">Redis网络模型</a><time datetime="2024-07-21T09:01:30.000Z" title="发表于 2024-07-21 17:01:30">2024-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/21/Redis/%E5%BA%95%E5%B1%82/Redis%E5%B8%B8%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" title="Redis常用的数据类型">Redis常用的数据类型</a><time datetime="2024-07-21T08:49:42.000Z" title="发表于 2024-07-21 16:49:42">2024-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/21/Redis/%E5%BA%95%E5%B1%82/Redis%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="Redis底层数据结构">Redis底层数据结构</a><time datetime="2024-07-21T08:37:24.000Z" title="发表于 2024-07-21 16:37:24">2024-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/21/JVM/10-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" title="10-垃圾回收器">10-垃圾回收器</a><time datetime="2024-07-21T03:35:10.000Z" title="发表于 2024-07-21 11:35:10">2024-07-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/07/21/JVM/9-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/" title="9-垃圾回收算法">9-垃圾回收算法</a><time datetime="2024-07-21T03:35:03.000Z" title="发表于 2024-07-21 11:35:03">2024-07-21</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/JVM/"><span class="card-category-list-name">JVM</span><span class="card-category-list-count">10</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Redis/"><span class="card-category-list-name">Redis</span><span class="card-category-list-count">3</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Redis/%E5%BA%95%E5%B1%82/"><span class="card-category-list-name">底层</span><span class="card-category-list-count">3</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><span class="card-category-list-name">编译原理</span><span class="card-category-list-count">8</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.1em; color: #999">底层数据结构</a> <a href="/tags/JVM/" style="font-size: 1.5em; color: #99a9bf">JVM</a> <a href="/tags/Redis/" style="font-size: 1.23em; color: #999ea6">Redis</a> <a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" style="font-size: 1.37em; color: #99a4b2">编译原理</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><span class="card-archive-list-count">21</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">21</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-07-21T09:06:50.681Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lihh</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>